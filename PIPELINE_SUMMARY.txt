================================================================================
QUANTUM TEST SELECTION PIPELINE - FINAL PACKAGE
================================================================================

DESCRIPTION:
-----------
A complete, self-contained test suite optimization framework using
quantum-inspired algorithms and classical baselines. This package is
ready to deploy on any software project with minimal adaptation.

================================================================================
PACKAGE CONTENTS
================================================================================

Core Algorithm Files:
--------------------
1. advanced_qubo_creation.py
   - 5-stage QUBO builder with adaptive reweighting
   - Uses coverage matrix to build optimization problem
   - No arbitrary constants, all weights data-driven

2. basic_simulated_annealing.py
   - Classical SA baseline for comparison
   - Minimizes (1 - coverage) + alpha * (size penalty)
   - Fast and reliable fallback method

3. basic_adaptive.py
   - Greedy adaptive baseline
   - Selects tests based on marginal coverage gain
   - Simple and efficient for quick results

4. quantum_annealer_simulator.py
   - QAOA implementation using PennyLane
   - Converts QUBO to quantum Hamiltonian
   - Simulates quantum annealing on classical hardware

Orchestration:
-------------
5. run_full_pipeline.py
   - End-to-end pipeline execution
   - Runs all three methods and compares results
   - Generates CSV summary output

Utilities:
---------
6. build_coverage_template.py
   - Template for building coverage matrices
   - Includes examples for pytest, gcov, synthetic data
   - Adapt to your specific coverage tool

Configuration:
-------------
7. config/baselines.json
   - Default hyperparameters for all algorithms
   - Easily customizable for your needs
   - Controls coverage targets, penalties, SA parameters

Documentation:
-------------
8. README.md
   - Comprehensive documentation
   - Architecture overview
   - API reference

9. QUICKSTART.md
   - 5-minute quick start guide
   - Common use cases
   - Troubleshooting tips

10. USAGE_GUIDE.txt
    - Detailed usage instructions
    - Input format specifications
    - Examples for different languages

11. LICENSE
    - MIT License for open use

Examples:
--------
12. examples/complete_example.py
    - Full working demonstration
    - Synthetic data generation
    - All methods execution
    - Result comparison

Dependencies:
------------
13. requirements.txt
    - Core: numpy, scipy, pennylane
    - Optional: pytest, coverage, matplotlib

================================================================================
INPUT FORMAT SPECIFICATION
================================================================================

REQUIRED: Coverage Matrix
-------------------------
File: results/C_<project>.npz
Type: NumPy compressed archive

Structure:
  C: np.ndarray of shape (N_tests, M_branches)
     Binary matrix where C[i,j] = 1 if test i covers branch j

Creation example:
  import numpy as np
  C = np.array([[1, 0, 1],  # test 0 covers branches 0, 2
                [0, 1, 1],  # test 1 covers branches 1, 2
                [1, 1, 0]]) # test 2 covers branches 0, 1
  np.savez('results/C_myproject.npz', C=C)

OPTIONAL: Branch Metadata
-------------------------
File: branches.json
Type: JSON array

Fields (required):
  - id: unique identifier
  - line: source line number
  - condition: description
  - expr: expression

Fields (optional):
  - complexity: ["low", "medium", "high", "very_high"]
  - overlap_group: logical grouping
  - criticality: numerical weight

OPTIONAL: Configuration
-----------------------
File: config/baselines.json
Type: JSON object

Parameters:
  - target_coverage: 0.8 (desired coverage ratio)
  - alpha_size_penalty: 0.2 (SA penalty)
  - beta_size_penalty: 0.5 (adaptive penalty)
  - initial_temperature: 1.0
  - final_temperature: 0.001
  - steps: 5000
  - seed: 42

================================================================================
USAGE WORKFLOW
================================================================================

Step 1: Install Dependencies
----------------------------
  pip install -r requirements.txt

Step 2: Prepare Coverage Data
-----------------------------
  # Option A: Use template to build from your coverage tool
  python build_coverage_template.py --mode pytest \
      --test-dir tests/ --source-dir src/

  # Option B: Create manually from your data
  python -c "
  import numpy as np
  C = your_coverage_matrix
  np.savez('results/C_myproject.npz', C=C)
  "

Step 3: Run Pipeline
-------------------
  python run_full_pipeline.py --coverage results/C_myproject.npz

Step 4: View Results
-------------------
  cat results/comparison.csv
  cat results/baselines_sa_result.json
  cat results/baselines_adaptive_result.json
  cat results/advanced_results.json

================================================================================
OUTPUT FORMAT
================================================================================

CSV Summary (results/comparison.csv):
------------------------------------
Method,FV,Coverage,Tests
Basic_Simulated_Annealing,0.024,1.0,6
Basic_Adaptive_Greedy,0.086,0.944,3
Advanced_QAOA,-3.206,1.0,6

JSON Details (results/*.json):
-----------------------------
{
  "method": "Advanced_QAOA",
  "coverage_ratio": 0.95,
  "selected_count": 25,
  "total_tests": 100,
  "selected_indices": [0, 5, 12, ...],
  "energy": -245.67,
  "config": { ... }
}

================================================================================
ADAPTING TO YOUR SOFTWARE
================================================================================

Language-Specific Coverage Collection:
--------------------------------------

Python (pytest + coverage.py):
  coverage run -m pytest tests/
  coverage json -o coverage.json
  # Parse coverage.json to build C matrix

C/C++ (gcov):
  gcc -fprofile-arcs -ftest-coverage program.c
  ./program < test_input.txt
  gcov program.c
  # Parse .gcov files to build C matrix

Java (JaCoCo):
  mvn test jacoco:report
  # Parse target/site/jacoco/jacoco.xml to build C matrix

JavaScript (Istanbul/nyc):
  nyc --reporter=json mocha tests/
  # Parse coverage/coverage-final.json to build C matrix

Any Other Language:
  Use any branch coverage tool that outputs test Ã— branch data
  Convert to NumPy matrix format as shown above

================================================================================
KEY FEATURES
================================================================================

1. No Magic Numbers
   - All weights derived from coverage matrix structure
   - Data-driven coefficient initialization
   - Ratio-based adaptive updates

2. Multi-Method Comparison
   - Classical baselines (SA, Adaptive)
   - Advanced quantum-inspired QUBO
   - Side-by-side performance metrics

3. Flexible Configuration
   - JSON-based hyperparameter tuning
   - Command-line parameter overrides
   - Sensible defaults provided

4. Production Ready
   - Robust error handling
   - Automatic fallbacks on quantum solver failure
   - Comprehensive logging

5. Well Documented
   - Clear input format specifications
   - Usage examples for multiple languages
   - Troubleshooting guides

6. Open Source
   - MIT License
   - Easy to modify and extend
   - No proprietary dependencies

================================================================================
ALGORITHMS SUMMARY
================================================================================

1. Basic Simulated Annealing (SA)
   Objective: minimize (1 - coverage) + alpha * (selected_tests / total_tests)
   Method: Geometric cooling with Metropolis acceptance
   Time: O(steps * N) where N = number of tests
   Space: O(N + M) where M = number of branches

2. Basic Adaptive Greedy
   Strategy: Select test with max (new_coverage - beta)
   Method: Iterative greedy selection until target reached
   Time: O(N^2 * M) worst case
   Space: O(N + M)

3. Advanced QUBO (5-stage with Quantum Annealing)
   Stage 1: Coverage efficiency analysis (redundancy-normalized)
   Stage 2: Gap escalation with criticality
   Stage 3: Unexplored test reward boosting
   Stage 4: Overlap coupling refinement
   Stage 5: Pipeline quality-based global scaling
   Solver: QAOA with PennyLane (2 layers, COBYLA optimization)
   Time: O(iterations * QAOA_time)
   Space: O(N^2) for QUBO matrix

================================================================================
DEPLOYMENT CHECKLIST
================================================================================

[X] Core algorithm files (4 files)
[X] Pipeline orchestration (1 file)
[X] Coverage builder template (1 file)
[X] Default configuration (1 file)
[X] Documentation (README, QUICKSTART, USAGE_GUIDE)
[X] Working example (1 file)
[X] Dependencies list (requirements.txt)
[X] License (MIT)
[X] Directory structure (config/, examples/, results/)
[X] No emojis in code or documentation

READY FOR DISTRIBUTION: YES

================================================================================
CONTACT AND SUPPORT
================================================================================

For questions or issues:
1. Read documentation in README.md
2. Try examples/complete_example.py
3. Check USAGE_GUIDE.txt for troubleshooting
4. Review build_coverage_template.py for coverage collection

================================================================================
VERSION INFORMATION
================================================================================

Package: Quantum Test Selection Pipeline
Version: 1.0
Date: November 2024
License: MIT
Python: >= 3.7
Dependencies: numpy, scipy, pennylane (see requirements.txt)

================================================================================
